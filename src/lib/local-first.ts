import {
	createEvolu,
	id,
	type kysely,
	NonEmptyString100,
	NonEmptyString1000,
	OwnerId,
	SimpleName,
	String100,
	String1000,
	sqliteTrue,
} from "@evolu/common";
import { createUseEvolu } from "@evolu/react";
import { evoluReactWebDeps, localAuth } from "@evolu/react-web";
import toast from "react-hot-toast";

const REACTIONS_LIMIT = 100;

export const UserId = id("User");
export type UserId = typeof UserId.Type;
export const ChannelId = id("Channel");
export type ChannelId = typeof ChannelId.Type;
export const MessageId = id("Message");
export type MessageId = typeof MessageId.Type;
export const ReactionId = id("Reaction");
export type ReactionId = typeof ReactionId.Type;

export const Schema = {
	user: {
		id: UserId,
		networkUuid: NonEmptyString100,
		displayName: String100,
		pfpUrl: String1000,
		bio: String1000,
		publicNtfyShId: String100,
		privateNtfyShId: String100,
		status: String100,
	},
	channel: {
		id: ChannelId,
		name: NonEmptyString100,
		description: String1000,
		pfpUrl: String1000,
	},
	message: {
		id: MessageId,
		content: NonEmptyString1000,
		user: NonEmptyString1000,
		channelId: NonEmptyString100,
		createdBy: OwnerId,
		// Network message ID generated by the message originator - used for matching across distributed stores
		networkMessageId: NonEmptyString100,
		networkTimestamp: NonEmptyString100, // stringified Unix timestamp number type
	},
	reaction: {
		id: ReactionId,
		messageId: MessageId,
		networkMessageId: NonEmptyString100, // Denormalized: network message ID for matching across distributed stores
		reaction: NonEmptyString100,
		channelId: NonEmptyString100,
		createdBy: OwnerId,
		networkTimestamp: NonEmptyString100, // stringified Unix timestamp number type
	},
};

// Namespace for the current app (scopes databases, passkeys, etc.)
export const service = "pwa-react-151125";

// N.B.: this is a top-level await
const authResult = await localAuth.getOwner({ service });

// Create Evolu instance for the React web platform.
export const evoluInstance = createEvolu(evoluReactWebDeps)(Schema, {
	name: SimpleName.orThrow(`${service}-${authResult?.owner?.id ?? "guest"}`),
	encryptionKey: authResult?.owner?.encryptionKey,
	externalAppOwner: authResult?.owner,

	transports: [
		{ type: "WebSocket", url: "wss://evolu-relay-1.artlu.xyz" },
		// { type: "WebSocket", url: "wss://evolu-relay-2.artlu.xyz" },
		// { type: "WebSocket", url: "wss://free.evoluhq.com" },
	],
});

/**
 * Subscribe to unexpected Evolu errors (database, network, sync issues). These
 * should not happen in normal operation, so always log them for debugging. Show
 * users a friendly error message instead of technical details.
 */
evoluInstance.subscribeError(() => {
	const error = evoluInstance.getError();
	if (!error) return;

	if (error.type === "ProtocolQuotaError") {
		// TODO: handle this
		// swallow this error
		return;
	}

	if (error.type === "SqliteError" && error.error.type === "TransferableError") {
		toast.error("Known issue with Private Mode. Use regular mode, and clear browser history afterwards.");
		console.error(error);
		return;
	}
	if (error.type === "SqliteError") {
		toast.error("ðŸš¨ Evolu error occurred! Check the console.");
		console.error(error);
		return;
	}

	console.error(error);
});

export const useEvolu = createUseEvolu(evoluInstance);

// Columns createdAt, updatedAt, isDeleted are auto-added to all tables.

// Soft delete: filter out deleted rows.

// Like with GraphQL, all columns except id are nullable in queries
// (even if defined without nullOr in the schema) to allow schema
// evolution without migrations. Filter nulls with where + $narrowType.

export const usersQuery = (networkUuid: NonEmptyString100) =>
	evoluInstance.createQuery((db) =>
		db
			.selectFrom("user")
			.select(["id", "displayName", "pfpUrl", "bio", "publicNtfyShId", "status"])
			.where("networkUuid", "is", networkUuid)
			.where("isDeleted", "is not", sqliteTrue)
			.$narrowType<{
				displayName: kysely.NotNull;
				pfpUrl: kysely.NotNull;
				bio: kysely.NotNull;
				publicNtfyShId: kysely.NotNull;
			}>(),
	);

export const messagesQuery = (ownerId?: OwnerId) =>
	evoluInstance.createQuery((db) =>
		ownerId
			? db
					.selectFrom("message")
					.select([
						"id",
						"content",
						"channelId",
						"createdBy",
						"createdAt",
						"updatedAt",
						"networkMessageId",
						"networkTimestamp",
					])
					.where("createdBy", "is", ownerId)
					.where("isDeleted", "is not", sqliteTrue)
					.$narrowType<{
						content: kysely.NotNull;
						channelId: kysely.NotNull;
						networkMessageId: kysely.NotNull;
					}>()
					.orderBy("createdAt", "asc")
			: db
					.selectFrom("message")
					.select([
						"id",
						"content",
						"channelId",
						"createdBy",
						"createdAt",
						"updatedAt",
						"networkMessageId",
						"networkTimestamp",
					])
					.where("isDeleted", "is not", sqliteTrue)
					.$narrowType<{
						content: kysely.NotNull;
						channelId: kysely.NotNull;
						networkMessageId: kysely.NotNull;
					}>()
					.orderBy("message.createdAt", "asc"),
	);
export type MessagesRow = ReturnType<typeof messagesQuery>["Row"];

export const reactionsQuery = (messageId: MessageId) =>
	evoluInstance.createQuery((db) =>
		db
			.selectFrom("reaction")
			.select(["id", "reaction", "channelId", "createdBy", "updatedAt"])
			.where("messageId", "is", messageId)
			.where("isDeleted", "is not", sqliteTrue)
			.$narrowType<{ reaction: kysely.NotNull }>()
			.orderBy("updatedAt", "desc"),
	);
export type ReactionsRow = ReturnType<typeof reactionsQuery>["Row"];

// Query all reactions for a message including deleted ones for upsert
export const allReactionsQuery = (messageId: MessageId) =>
	evoluInstance.createQuery((db) =>
		db
			.selectFrom("reaction")
			.select([
				"id",
				"reaction",
				"channelId",
				"createdBy",
				"updatedAt",
				"isDeleted",
				"messageId",
			])
			.where("messageId", "is", messageId)
			.$narrowType<{ reaction: kysely.NotNull }>(),
	);
export type AllReactionsRow = ReturnType<typeof allReactionsQuery>["Row"];

// Query all reactions for all messages including deleted ones for websocket handler
export const allReactionsForAllMessagesQuery = () =>
	evoluInstance.createQuery((db) =>
		db
			.selectFrom("reaction")
			.select([
				"id",
				"reaction",
				"channelId",
				"createdBy",
				"updatedAt",
				"isDeleted",
				"messageId",
			])
			.$narrowType<{ reaction: kysely.NotNull }>(),
	);
export type AllReactionsForAllMessagesRow = ReturnType<
	typeof allReactionsForAllMessagesQuery
>["Row"];

// Query messages for a specific channel
export const messagesForChannelQuery = (channelId: NonEmptyString100) =>
	evoluInstance.createQuery((db) =>
		db
			.selectFrom("message")
			.select([
				"id",
				"content",
				"user",
				"channelId",
				"createdBy",
				"createdAt",
				"updatedAt",
				"networkMessageId",
				"networkTimestamp",
			])
			.where("channelId", "is", channelId)
			.where("isDeleted", "is not", sqliteTrue)
			.$narrowType<{
				content: kysely.NotNull;
				channelId: kysely.NotNull;
				networkMessageId: kysely.NotNull;
			}>()
			.orderBy("createdAt", "asc"),
	);
export type MessagesForChannelRow = ReturnType<
	typeof messagesForChannelQuery
>["Row"];

// Query all reactions for a specific channel including deleted ones for websocket handler
// Now uses networkMessageId directly from reaction table (no join needed)
export const allReactionsForChannelQuery = (channelId: NonEmptyString100) =>
	evoluInstance.createQuery((db) =>
		db
			.selectFrom("reaction")
			.select([
				"id",
				"reaction",
				"channelId",
				"createdBy",
				"updatedAt",
				"isDeleted",
				"messageId",
				"networkMessageId",
			])
			.where("channelId", "is", channelId)
			.where("networkMessageId", "is not", null)
			.$narrowType<{ reaction: kysely.NotNull; networkMessageId: kysely.NotNull }>(),
	);
export type AllReactionsForChannelRow = ReturnType<
	typeof allReactionsForChannelQuery
>["Row"];

// Query reactions for a specific networkMessageId (finds reactions across all local message copies)
// This is used to prevent double-counting when multiple instances have the same message
// Now uses networkMessageId directly from reaction table (no join needed)
export const reactionsForNetworkMessageIdQuery = (
	networkMessageId: NonEmptyString100,
	limit: number = REACTIONS_LIMIT,
) =>
	evoluInstance.createQuery((db) =>
		db
			.selectFrom("reaction")
			.select([
				"id",
				"reaction",
				"channelId",
				"createdBy",
				"updatedAt",
				"isDeleted",
				"messageId",
				"networkMessageId",
			])
			.where("networkMessageId", "is", networkMessageId)
			.where("isDeleted", "is not", sqliteTrue)
			.$narrowType<{ reaction: kysely.NotNull; networkMessageId: kysely.NotNull }>()
			.orderBy("updatedAt", "asc")
			.limit(limit),
	);
export type ReactionsForNetworkMessageIdRow = ReturnType<
	typeof reactionsForNetworkMessageIdQuery
>["Row"];

export const userQuery = (networkUuid: NonEmptyString100) =>
	evoluInstance.createQuery((db) =>
		db
			.selectFrom("user")
			.select(["id", "displayName", "pfpUrl", "bio", "status", "publicNtfyShId"])
			.where("networkUuid", "is", networkUuid)
			.where("isDeleted", "is not", sqliteTrue)
			.$narrowType<{
				displayName: kysely.NotNull;
				pfpUrl: kysely.NotNull;
				bio: kysely.NotNull;
				status: kysely.NotNull;
				publicNtfyShId: kysely.NotNull;
			}>(),
	);
export type UserRow = ReturnType<typeof userQuery>["Row"];

// n.b. channelId is the local id, not the network id
export const channelQuery = (channelId: ChannelId) =>
	evoluInstance.createQuery((db) =>
		db
			.selectFrom("channel")
			.select(["id", "name", "description", "pfpUrl"])
			.where("id", "is", channelId)
			.where("isDeleted", "is not", sqliteTrue)
			.$narrowType<{
				name: kysely.NotNull;
				description: kysely.NotNull;
				pfpUrl: kysely.NotNull;
				encryptionKey: kysely.NotNull;
			}>(),
	);
export type ChannelRow = ReturnType<typeof channelQuery>["Row"];
