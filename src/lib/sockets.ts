import { connect, type IttySocket } from "itty-sockets";
import { z } from "zod";
import { isValidWebSocketUrl } from "./helpers";
import type { SerializedEncryptedData } from "./symmetric-encryption";

export const WSS_SERVER_URL = "wss://itty.ws";

// constants for message matching, de-duplication, and cleanup
const CLEANUP_INTERVAL_MS = 10000; // 10 seconds

export interface WsMessage<T> {
	date: number; // Unix timestamp of original message
	uid: string; // unique user ID of the sending connection
	message: T; // your message payload
}

export enum WsMessageType {
	DOORBELL = "doorbell",
	MARCO_POLO = "marco_polo",
	STATUS = "status",
	REACTION = "reaction",
	TEXT = "text",
	DELETE = "delete",
	REFRESH = "refresh",
}

export enum TypingIndicatorType {
	TYPING = "typing",
	STOP_TYPING = "stop_typing",
}

export enum DoorbellType {
	OPEN = "hello", // likely to be duplicated
	CLOSE = "bye", // unreliable
}

export interface BaseWsMessage {
	type: WsMessageType;
	channelId: string;
	networkMessageId?: string;
}

export interface TypingIndicatorMessage extends BaseWsMessage {
	uuid?: string;
	type: WsMessageType.STATUS;
	presence: TypingIndicatorType;
	text?: string;
}

export interface DoorbellMessage extends BaseWsMessage {
	uuid?: string;
	type: WsMessageType.DOORBELL;
	message: DoorbellType;
}

export interface ChannelData {
	id: string;
	name?: string|null;
	description?: string|null;
	pfpUrl?: string|null;
	publicUselessEncryptionKey?: string|null;
}

export const ChannelDataSchema = z.object({
	id: z.string(),
	name: z.string().nullable().optional(),
	description: z.string().nullable().optional(),
	pfpUrl: z.string().nullable().optional(),
	publicUselessEncryptionKey: z.string().nullable().optional(),
});

/**
 * Historical user data that should be preserved from the time a message was sent.
 * These fields provide context about the user's state when they sent the message.
 */
export interface HistoricalUserData {
	status: string; // Ephemeral status at message time (e.g., "Working", "On break")
	bio: string; // Bio at message time (may explain context of what they said)
}

/**
 * Current user data that should always reflect the latest state.
 * These fields are used for recognition and functionality, not historical context.
 */
export interface CurrentUserData {
	displayName: string; // Current name (for recognition across old messages)
	pfpUrl: string; // Current profile picture (for recognition)
	publicNtfyShId: string; // Current notification ID (for functionality)
}

/**
 * Complete user message data combining both historical and current fields.
 * Used in messages for backward compatibility and when sending new messages.
 */
export interface UserMessageData extends HistoricalUserData, CurrentUserData {}

// TODO: add validation, currently breaks at 1000 chars total JSON object
export const UserMessageDataSchema = z.object({
	displayName: z.string(), // can be empty but not null
	pfpUrl: z.string(), // TODO: add validation for urls
	bio: z.string(),
	status: z.string().optional(),
	publicNtfyShId: z.string().optional(),
});

export interface MarcoPoloMessage extends BaseWsMessage {
	uuid?: string;
	type: WsMessageType.MARCO_POLO;
	message: {user?: UserMessageData, channel?: ChannelData};
}

export interface TextMessage extends BaseWsMessage {
	uuid: string;
	type: WsMessageType.TEXT;
	content: string;
	user: UserMessageData;
	networkMessageId: string; // Generated by the message originator, used for matching across distributed stores
	networkTimestamp: string; // stringified Unix timestamp number type
	autoResponder: boolean;
}

export interface ReactionMessage extends BaseWsMessage {
	uuid: string;
	type: WsMessageType.REACTION;
	networkMessageId: string; // Network message ID from the original message, used for matching across distributed stores
	networkTimestamp: string; // stringified Unix timestamp number type
	reaction: string;
	isDeleted: boolean;
}

export interface DeleteMessage extends BaseWsMessage {
	uuid?: string;  // the user deleting the message (should be the original sender)
	type: WsMessageType.DELETE;
	networkMessageId: string; // Network message ID from the original message, used for matching across distributed stores
	networkTimestamp?: string; // stringified Unix timestamp from local updatedAt
	signature: null; // placeholder for signature verification
}

export interface RefreshMessage extends BaseWsMessage {
	uuid: never;
	type: WsMessageType.REFRESH;
}

export interface EncryptedMessage extends BaseWsMessage {
	uuid: never;
	payload: SerializedEncryptedData;
}

export type KnownMessage = TypingIndicatorMessage | DoorbellMessage | MarcoPoloMessage | TextMessage | ReactionMessage | DeleteMessage | RefreshMessage | EncryptedMessage;

export function isTypingIndicatorMessage(
	message: unknown,
): message is TypingIndicatorMessage {
	return (
		typeof message === "object" &&
		message !== null &&
		"type" in message &&
		message.type === WsMessageType.STATUS &&
		"presence" in message &&
		(message.presence === TypingIndicatorType.TYPING ||
			message.presence === TypingIndicatorType.STOP_TYPING)
	);
}

export function isTextMessage(message: unknown): message is TextMessage {
	return (
		typeof message === "object" &&
		message !== null &&
		"type" in message &&
		message.type === WsMessageType.TEXT &&
		"uuid" in message &&
		"networkMessageId" in message &&
		"user" in message
	);
}

export function isDoorbellMessage(
	message: unknown,
): message is DoorbellMessage {
	return (
		typeof message === "object" &&
		message !== null &&
		"type" in message &&
		message.type === WsMessageType.DOORBELL &&
		"message" in message &&
		(message.message === DoorbellType.OPEN ||
			message.message === DoorbellType.CLOSE)
	);
}

export function isMarcoPoloMessage(message: unknown): message is MarcoPoloMessage {
	return (
		typeof message === "object" &&
		message !== null &&
		"type" in message &&
		message.type === WsMessageType.MARCO_POLO &&
		"channelId" in message
	);
}

export function isReactionMessage(
	message: unknown,
): message is ReactionMessage {
	return (
		typeof message === "object" &&
		message !== null &&
		"type" in message &&
		message.type === WsMessageType.REACTION &&
		"uuid" in message && message.uuid !== undefined &&		"networkMessageId" in message &&
		"reaction" in message &&
		"channelId" in message &&
		"isDeleted" in message &&
		typeof message.isDeleted === "boolean"
	);
}

export function isDeleteMessage(message: unknown): message is DeleteMessage {
	return (
		typeof message === "object" &&
		message !== null &&
		"type" in message &&
		message.type === WsMessageType.DELETE &&
		"networkMessageId" in message &&
		"channelId" in message
	);
}

export function isRefreshMessage(message: unknown): message is RefreshMessage {
	return (
		typeof message === "object" &&
		message !== null &&
		"type" in message &&
		message.type === WsMessageType.REFRESH &&
		"channelId" in message
	);
}

export function isEncryptedMessage(message: unknown): message is EncryptedMessage {
	if (typeof message !== "object" || message === null) return false;
	const m = message as Record<string, unknown>;
	return (
		"type" in m &&
		"channelId" in m &&
		"payload" in m &&
		typeof m.payload === "object" &&
		m.payload !== null &&
		"nonce" in (m.payload as Record<string, unknown>) &&
		"ciphertext" in (m.payload as Record<string, unknown>)
	);
}

export class TypedWsClient {
	private socket: IttySocket;
	private seenMessages: Set<string> = new Set();
	private cleanupInterval: number | null = null;

	constructor(channelId: string, wssServer: string) {
		if (!isValidWebSocketUrl(wssServer)) {
			throw new Error(
				`Invalid WebSocket server URL: ${wssServer}. Must start with ws:// or wss://`,
			);
		}
		this.socket = connect(`${wssServer}/c/${channelId}`);
		// Clean up old message IDs periodically to prevent memory leaks
		this.cleanupInterval = window.setInterval(() => {
			// The Set will naturally handle cleanup as we only add recent messages
			// For a more sophisticated cleanup, we could track timestamps, but
			// the Set size should remain bounded by message frequency
			if (this.seenMessages.size > 1000) {
				this.seenMessages.clear();
			}
		}, CLEANUP_INTERVAL_MS);
	}

	/**
	 * Get the underlying socket object for direct access to connection information.
	 * The socket object is live and updates in real-time.
	 */
	public getSocket(): IttySocket {
		return this.socket;
	}

	private getMessageKey(wsMessage: WsMessage<KnownMessage>): string | null {
		const { message } = wsMessage;

		// De-dup TEXT messages by networkMessageId
		// Note: We include the message type in the key to prevent DELETE/REACTION
		// messages from being filtered out as duplicates of TEXT messages with the same networkMessageId
		if (isTextMessage(message) && message.networkMessageId) {
			return `text:${message.networkMessageId}`;
		}

		// REACTION messages: No socket-level deduplication needed
		// Database-level matching in ReactionMessageHandler ensures idempotency
		// (messageId + createdBy + reaction uniquely identifies reactions)
		if (isReactionMessage(message)) {
			return null; // No deduplication at socket level
		}

		// DELETE messages: No socket-level deduplication needed
		// Database-level update is idempotent (setting isDeleted=true multiple times is safe)
		if (isDeleteMessage(message)) {
			return null; // No deduplication at socket level
		}

		// Other message types don't need de-dup (STATUS, DOORBELL are idempotent or stateful)
		return null;
	}

	private isDuplicate(wsMessage: WsMessage<KnownMessage>): boolean {
		const key = this.getMessageKey(wsMessage);
		if (!key) return false;

		if (this.seenMessages.has(key)) return true;

		this.seenMessages.add(key);
		return false;
	}

	public on(event: WsMessageType, callback: (message: WsMessage<KnownMessage>) => void) {
		this.socket.on(event as string, (wsMessage: WsMessage<KnownMessage>) => {
			// De-duplicate before calling the callback
			if (this.isDuplicate(wsMessage)) {
				return; // Skip duplicate message
			}
			callback(wsMessage);
		});
	}

	public safeSend(message: KnownMessage) {
		try {
			this.socket.send(message);
		} catch (err) {
			console.error("Failed to send message", err);
		}
	}

	public destroy() {
		// Clear the cleanup interval
		if (this.cleanupInterval !== null) {
			window.clearInterval(this.cleanupInterval);
			this.cleanupInterval = null;
		}
		// Clear seen messages
		this.seenMessages.clear();
		// Close the socket connection if it has a close method
		if (this.socket && typeof (this.socket as { close?: () => void }).close === "function") {
			(this.socket as { close: () => void }).close();
		}
	}
}
