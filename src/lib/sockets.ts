import { connect, type IttySocket } from "itty-sockets";
import { z } from "zod";
import type { SerializedEncryptedData } from "./helpers";

// constants for message matching, de-duplication, and cleanup
const TIME_ROUNDING_MS = 100; // Round timestamps to 100ms for matching
const CLEANUP_INTERVAL_MS = 10000; // 10 seconds

export type WsMessage = {
	date: number; // Unix timestamp of original message
	uid: string; // unique user ID of the sending connection
	message: unknown; // your message payload
};

export enum WsMessageType {
	DOORBELL = "doorbell",
	MARCO_POLO = "marco_polo",
	STATUS = "status",
	REACTION = "reaction",
	TEXT = "text",
	DELETE = "delete",
	REFRESH = "refresh",
}

export enum TypingIndicatorType {
	TYPING = "typing",
	STOP_TYPING = "stop_typing",
}

export enum DoorbellType {
	OPEN = "hello",
	CLOSE = "bye",
}

export interface TypingIndicatorMessage {
	uuid?: string;
	type: WsMessageType.STATUS;
	presence: TypingIndicatorType;
	text?: string;
	channelId: string;
}

export interface DoorbellMessage {
	uuid?: string;
	type: WsMessageType.DOORBELL;
	message: DoorbellType;
	channelId: string;
}

export interface ChannelData {
	id: string;
	name?: string|null;
	description?: string|null;
	pfpUrl?: string|null;
	publicUselessEncryptionKey?: string|null;
}

export const ChannelDataSchema = z.object({
	id: z.string(),
	name: z.string().nullable().optional(),
	description: z.string().nullable().optional(),
	pfpUrl: z.string().nullable().optional(),
	publicUselessEncryptionKey: z.string().nullable().optional(),
});

export interface UserMessageData {
	displayName: string;
	pfpUrl: string;
	bio: string;
}

export const UserMessageDataSchema = z.object({
	displayName: z.string(), // can be empty but not null
	pfpUrl: z.string(), // TODO: add validation
	bio: z.string(), // TODO: add validation, currently breaks at 1000 chars total JSON object
});

export interface MarcoPoloMessage {
	uuid?: string;
	type: WsMessageType.MARCO_POLO;
	message: {user?: UserMessageData, channel?: ChannelData};
	channelId: string;
}

export interface TextMessage {
	uuid: string;
	type: WsMessageType.TEXT;
	content: string | SerializedEncryptedData;
	user: UserMessageData ; // SerializedEncryptedData;
	channelId: string;
	encrypted: boolean;
	networkMessageId: string; // Generated by the message originator, used for matching across distributed stores
	// Note: createdAt removed - we use envelope timestamp (e.date) instead for consistency
}

export interface ReactionMessage {
	uuid: string;
	type: WsMessageType.REACTION;
	networkMessageId: string; // Network message ID from the original message, used for matching across distributed stores
	reaction: string;
	channelId: string; // plaintext
	isDeleted: boolean;
}

export interface DeleteMessage {
	uuid?: string;  // the user deleting the message (should be the original sender)
	type: WsMessageType.DELETE;
	networkMessageId: string; // Network message ID from the original message, used for matching across distributed stores
	channelId: string; // plaintext
	signature: null; // placeholder for signature verification
}

export interface RefreshMessage {
	type: WsMessageType.REFRESH;
	channelId: string; // plaintext
}

export function isTypingIndicatorMessage(
	message: unknown,
): message is TypingIndicatorMessage {
	return (
		typeof message === "object" &&
		message !== null &&
		"type" in message &&
		message.type === WsMessageType.STATUS &&
		"presence" in message &&
		(message.presence === TypingIndicatorType.TYPING ||
			message.presence === TypingIndicatorType.STOP_TYPING)
	);
}

export function isTextMessage(message: unknown): message is TextMessage {
	return (
		typeof message === "object" &&
		message !== null &&
		"type" in message &&
		message.type === WsMessageType.TEXT &&
		"uuid" in message &&
		"networkMessageId" in message &&
		"user" in message
	);
}

export function isDoorbellMessage(
	message: unknown,
): message is DoorbellMessage {
	return (
		typeof message === "object" &&
		message !== null &&
		"type" in message &&
		message.type === WsMessageType.DOORBELL &&
		"message" in message &&
		(message.message === DoorbellType.OPEN ||
			message.message === DoorbellType.CLOSE)
	);
}

export function isMarcoPoloMessage(message: unknown): message is MarcoPoloMessage {
	return (
		typeof message === "object" &&
		message !== null &&
		"type" in message &&
		message.type === WsMessageType.MARCO_POLO &&
		"channelId" in message
	);
}

export function isReactionMessage(
	message: unknown,
): message is ReactionMessage {
	return (
		typeof message === "object" &&
		message !== null &&
		"type" in message &&
		message.type === WsMessageType.REACTION &&
		"uuid" in message && message.uuid !== undefined &&		"networkMessageId" in message &&
		"reaction" in message &&
		"channelId" in message &&
		"isDeleted" in message &&
		typeof message.isDeleted === "boolean"
	);
}

export function isDeleteMessage(message: unknown): message is DeleteMessage {
	return (
		typeof message === "object" &&
		message !== null &&
		"type" in message &&
		message.type === WsMessageType.DELETE &&
		"uuid" in message && message.uuid !== undefined &&
		"networkMessageId" in message &&
		"channelId" in message
	);
}

export function isRefreshMessage(message: unknown): message is RefreshMessage {
	return (
		typeof message === "object" &&
		message !== null &&
		"type" in message &&
		message.type === WsMessageType.REFRESH &&
		"channelId" in message
	);
}

export type TypingIndicatorWsMessage = WsMessage & {
	message: TypingIndicatorMessage;
};

export function isTypingIndicatorWsMessage(
	wsMessage: WsMessage,
): wsMessage is TypingIndicatorWsMessage {
	return isTypingIndicatorMessage(wsMessage.message);
}

export class TypedWsClient {
	private socket: IttySocket;
	private seenMessages: Set<string> = new Set();
	private cleanupInterval: number | null = null;

	constructor(channelId: string) {
		this.socket = connect(channelId);
		// Clean up old message IDs periodically to prevent memory leaks
		this.cleanupInterval = window.setInterval(() => {
			// The Set will naturally handle cleanup as we only add recent messages
			// For a more sophisticated cleanup, we could track timestamps, but
			// the Set size should remain bounded by message frequency
			if (this.seenMessages.size > 1000) {
				this.seenMessages.clear();
			}
		}, CLEANUP_INTERVAL_MS);
	}

	/**
	 * Get the underlying socket object for direct access to connection information.
	 * The socket object is live and updates in real-time.
	 */
	public getSocket(): IttySocket {
		return this.socket;
	}

	private getMessageKey(wsMessage: WsMessage): string | null {
		const { message, date } = wsMessage;

		// De-dup TEXT messages
		if (isTextMessage(message)) {
			return message.networkMessageId;
		}

		// De-dup REACTION messages: networkMessageId + sender + reaction + timestamp (use envelope timestamp)
		if (isReactionMessage(message)) {
			const roundedTime =
				Math.floor(date / TIME_ROUNDING_MS) * TIME_ROUNDING_MS;
			return `reaction:${message.networkMessageId}:${message.uuid}:${message.reaction}:${message.isDeleted}:${roundedTime}`;
		}

		// De-dup DELETE messages: networkMessageId + deleter + timestamp
		if (isDeleteMessage(message)) {
			const roundedTime =
				Math.floor(date / TIME_ROUNDING_MS) * TIME_ROUNDING_MS;
			return `delete:${message.networkMessageId}:${message.uuid}:${roundedTime}`;
		}

		// Other message types don't need de-dup (STATUS, DOORBELL are idempotent or stateful)
		return null;
	}

	private isDuplicate(wsMessage: WsMessage): boolean {
		const key = this.getMessageKey(wsMessage);
		if (!key) return false;

		if (this.seenMessages.has(key)) return true;

		this.seenMessages.add(key);
		return false;
	}

	public on(event: WsMessageType, callback: (message: WsMessage) => void) {
		this.socket.on(event as string, (wsMessage: WsMessage) => {
			// De-duplicate before calling the callback
			if (this.isDuplicate(wsMessage)) {
				return; // Skip duplicate message
			}
			callback(wsMessage);
		});
	}

	public safeSend(
		message:
			| TypingIndicatorMessage
			| DoorbellMessage
			| MarcoPoloMessage
			| TextMessage
			| ReactionMessage
			| DeleteMessage,
	) {
		try {
			this.socket.send(message);
		} catch (err) {
			console.error("Failed to send message", err);
		}
	}

	public destroy() {
		// Clear the cleanup interval
		if (this.cleanupInterval !== null) {
			window.clearInterval(this.cleanupInterval);
			this.cleanupInterval = null;
		}
		// Clear seen messages
		this.seenMessages.clear();
		// Close the socket connection if it has a close method
		// biome-ignore lint/suspicious/noExplicitAny: generic socket function
		if (this.socket && typeof (this.socket as any).close === "function") {
			// biome-ignore lint/suspicious/noExplicitAny: generic socket function
			(this.socket as any).close();
		}
	}
}
